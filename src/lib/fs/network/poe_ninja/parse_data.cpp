#include <fs/network/poe_ninja/parse_data.hpp>
#include <fs/network/exceptions.hpp>
#include <fs/utility/dump_json.hpp>
#include <fs/utility/string_helpers.hpp>
#include <fs/lang/market/item_price_data.hpp>
#include <fs/lang/keywords.hpp>
#include <fs/log/logger.hpp>

#include <nlohmann/json.hpp>

#include <vector>
#include <utility>

// autogenerated ninja's API doc: https://poe.ninja/swagger/index.html
namespace
{

using namespace fs;

// taken from JavaScript code on the site
// static/js/economy/pages/CurrencyDetailsPage.tsx
bool currency_is_low_confidence(const nlohmann::json& item) // (only for currency overview items)
{
	/*
	 * This is a hard choice. poe.ninja reports separate confidence
	 * for buying and selling. Some items with very high demand have
	 * selling property equal to null, but this does not mean the item
	 * has low confidence - only that trades gets completed very fast
	 * which is the case for high-demand (often expensive) items.
	 *
	 * I have gone for some compromise. We treat an item as low-confidence
	 * when the sum of buying and selling offers is < 10.
	 */
	const auto get_count = [&](const auto& side_name) {
		const auto it = item.find(side_name);
		if (it == item.end() || it->is_null()) {
			return 0;
		}

		return it->at("count").template get<int>();
	};

	const auto total_count = get_count("pay") + get_count("receive");
	return total_count < 10;
}

bool is_low_confidence(int count)
{
	return count < 5;
}

template <typename F>
void for_each_item(std::string_view json_str, log::logger& logger, F f)
{
	nlohmann::json json = nlohmann::json::parse(json_str);
	const auto it = json.find("lines");

	if (it == json.end()) {
		logger.error() << "Could not parse this JSON (first 200 characters): " << json_str.substr(0u, 200u);
		return;
	}

	for (const auto& item : *it) {
		try {
			f(item);
		}
		catch (const network::json_parse_error& e) {
			logger.warning() << "Failed to parse item entry: " << e.what()
				<< ", skipping this item: " << utility::dump_json(item) << '\n';
		}
		catch (const nlohmann::json::exception& e) {
			logger.warning() << e.what() << ", ignoring this item: " << utility::dump_json(item) << '\n';
		}
	}
}

[[nodiscard]] const std::string&
get_item_property_name(const nlohmann::json& item)
{
	return item.at("name").get_ref<const std::string&>();
}

[[nodiscard]] bool
get_item_property_corrupted(const nlohmann::json& item)
{
	if (const auto it = item.find("corrupted"); it == item.end())
		return false;
	else
		return it->get<bool>();
}

[[nodiscard]] int
get_item_property_gem_quality(const nlohmann::json& item)
{
	if (const auto it = item.find("gemQuality"); it == item.end())
		return 0;
	else
		return it->get<int>();
}

[[nodiscard]] int
get_item_property_links(const nlohmann::json& item)
{
	if (const auto it = item.find("links"); it == item.end())
		return 0;
	else
		return it->get<int>();
}

[[nodiscard]] int
get_item_property_stack_size(const nlohmann::json& item)
{
	if (const auto it = item.find("stackSize"); it == item.end())
		return 1;
	else
		return it->get<int>();
}


[[nodiscard]] lang::influence_info
get_item_property_influence_info(const nlohmann::json& item)
{
	const auto it = item.find("variant");
	if (it == item.end())
		return {};

	if (it->is_null())
		return {};

	const auto& infl = it->get_ref<const nlohmann::json::string_t&>();

	// poe.ninja reports influence in strings as "X" or "X/Y"
	// so we can safely use string-contains approach
	return lang::influence_info{
		utility::contains(infl, "Shaper"),
		utility::contains(infl, "Elder"),
		utility::contains(infl, "Crusader"),
		utility::contains(infl, "Redeemer"),
		utility::contains(infl, "Hunter"),
		utility::contains(infl, "Warlord")
	};
}

[[nodiscard]] lang::market::price_data // (only for currency overview items)
get_currency_price_data(const nlohmann::json& item)
{
	return lang::market::price_data{
		item.at("chaosEquivalent").get<double>(),
		currency_is_low_confidence(item)
	};
}

[[nodiscard]] lang::market::price_data
get_item_price_data(const nlohmann::json& item)
{
	return lang::market::price_data{
		item.at("chaosValue").get<double>(),
		is_low_confidence(item.at("count").get<int>())
	};
}

[[nodiscard]] lang::market::elementary_item
get_currency_item_data(const nlohmann::json& item)
{
	return lang::market::elementary_item{
		get_currency_price_data(item),
		item.at("currencyTypeName").get<std::string>()
	};
}

[[nodiscard]] lang::market::elementary_item
get_elementary_item_data(const nlohmann::json& item)
{
	return lang::market::elementary_item{
		get_item_price_data(item),
		get_item_property_name(item),
	};
}

[[nodiscard]] std::vector<lang::market::elementary_item>
parse_currency_items(std::string_view json_str, log::logger& logger)
{
	std::vector<lang::market::elementary_item> result;

	for_each_item(json_str, logger, [&](const auto& item) {
		result.push_back(get_currency_item_data(item));
	});

	return result;
}

[[nodiscard]] std::vector<lang::market::elementary_item>
parse_elementary_items(std::string_view json_str, log::logger& logger)
{
	std::vector<lang::market::elementary_item> result;

	for_each_item(json_str, logger, [&](const auto& item) {
		result.push_back(get_elementary_item_data(item));
	});

	return result;
}

[[nodiscard]] std::vector<lang::market::divination_card>
parse_divination_cards(std::string_view json_str, log::logger& logger)
{
	std::vector<lang::market::divination_card> result;

	for_each_item(json_str, logger, [&](const nlohmann::json& item) {
		result.emplace_back(
			get_elementary_item_data(item),
			get_item_property_stack_size(item)
		);
	});

	return result;
}

[[nodiscard]] std::vector<lang::market::gem>
parse_gems(std::string_view json_str, log::logger& logger)
{
	std::vector<lang::market::gem> result;

	for_each_item(json_str, logger, [&](const nlohmann::json& item) {
		result.emplace_back(
			get_elementary_item_data(item),
			item.at("gemLevel").get<int>(),
			get_item_property_gem_quality(item),
			get_item_property_corrupted(item)
		);
	});

	return result;
}

[[nodiscard]] std::vector<lang::market::base>
parse_bases(std::string_view json_str, log::logger& logger)
{
	std::vector<lang::market::base> result;

	for_each_item(json_str, logger, [&](const nlohmann::json& item) {
		// yes, not really a proper name but poe.ninja reuses some fields for other purposes
		const auto item_level = item.at("levelRequired").get<int>();
		result.emplace_back(
			get_elementary_item_data(item),
			item_level,
			get_item_property_influence_info(item)
		);
	});

	return result;
}

void parse_and_fill_uniques(
	std::string_view uniques_json,
	lang::market::unique_item_price_data& uniques,
	log::logger& logger)
{
	for_each_item(uniques_json, logger, [&](const nlohmann::json& item) {
		// skip uniques which are linked
		if (get_item_property_links(item) == 6) {
			return;
		}

		// skip uniques which are relics
		// currently the only way to determine a unique item is relic is checking
		// the pattern inside "detailsId" field of the item
		if (const auto& details = item.at("detailsId").get_ref<const nlohmann::json::string_t&>();
			details.find("-relic") != std::string::npos)
		{
			return;
		}

		// skip uniques which do not drop (eg fated items) - this will reduce ambiguity and
		// not pollute the filter with items we would not care for
		const auto& name = get_item_property_name(item);
		if (lang::market::is_undroppable_unique(name)) {
			return;
		}

		const auto& base_type = item.at("baseType").get_ref<const nlohmann::json::string_t&>();
		uniques.add_item(base_type, lang::market::elementary_item{get_item_price_data(item), name});
	});
}

} // namespace

namespace fs::network::poe_ninja
{

lang::market::item_price_data parse_item_price_data(const api_item_price_data& jsons, log::logger& logger)
{
	lang::market::item_price_data result;

	result.divination_cards = parse_divination_cards(jsons.divination_card, logger);

	result.currency  = parse_currency_items(jsons.currency, logger);
	result.fragments = parse_currency_items(jsons.fragment, logger);

	result.delirium_orbs   = parse_elementary_items(jsons.delirium_orb,   logger);
	result.oils            = parse_elementary_items(jsons.oil,            logger);
	result.incubators      = parse_elementary_items(jsons.incubator,      logger);
	result.scarabs         = parse_elementary_items(jsons.scarab,         logger);
	result.fossils         = parse_elementary_items(jsons.fossil,         logger);
	result.resonators      = parse_elementary_items(jsons.resonator,      logger);
	result.essences        = parse_elementary_items(jsons.essence,        logger);
	result.vials           = parse_elementary_items(jsons.vial,           logger);
	result.tattoos         = parse_elementary_items(jsons.tattoo,         logger);

	result.gems = parse_gems(jsons.skill_gem, logger);

	result.bases = parse_bases(jsons.base_type, logger);

	parse_and_fill_uniques(jsons.unique_armour, result.unique_eq, logger);
	parse_and_fill_uniques(jsons.unique_weapon, result.unique_eq, logger);
	parse_and_fill_uniques(jsons.unique_accessory, result.unique_eq, logger);

	parse_and_fill_uniques(jsons.unique_flask, result.unique_flasks, logger);

	parse_and_fill_uniques(jsons.unique_jewel, result.unique_jewels, logger);

	parse_and_fill_uniques(jsons.unique_map, result.unique_maps, logger);

	/*
	 * not all jsons are being read but:
	 * - we do not care about non-unique maps - people filter them by tier
	 * - we do not care about beasts - they do not drop
	 */
	return result;
}

}
